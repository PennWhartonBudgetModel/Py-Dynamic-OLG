##
# Reader and generator of parameters for dynamic model.
#

import PathFinder
import InputReader
import numpy as np
from scipy.stats import norm
import math

class ParamGenerator:
	
	# TIMING
	#     Includes policy-specific SS.NRA
	def timing(scenario):
		
		s['realage_entry']         = 20    # Real age of model age=0   
		s['T_life']                = 80    # Death year
		s['Tmax_work']             = 52    # Last possible year of working age     
		
		# Time range for transition path
		s['TransitionFirstYear'] = scenario.TransitionFirstYear
		s['TransitionLastYear']  = scenario.TransitionLastYear
		
		if scenario.isSteady():
			s['T_model']       = 1        # Steady state total modeling years
			s['startyears']    = 0        # Steady state cohort start year
			s['yearFirst']    = scenario.TransitionFirstYear - 1
			s['yearLast']     = s['yearFirst']
		else:
			s['yearFirst']     = scenario.TransitionFirstYear
			s['yearLast']      = scenario.TransitionLastYear - 1
			s['T_model']       = s['TransitionLastYear'] - s['TransitionFirstYear']
			s['startyears']    = list(range((-s['T_life']+1), s['T_model'])) # Transition path cohort start years
			
		return s
	
	## IMPORT GRIDS
	#   Import labor_productivity (grids, transition matrices, and initial
	#       household distribution) from csv files
	#   TBD: Import assets and average earnings grids
	def grids(scenario):
		
		timing    = ParamGenerator.timing(scenario)
		T_life    = timing['T_life']
		yearFirst = timing['yearFirst']
		yearLast  = timing['yearLast']
		   
		pathFinder = PathFinder(scenario)
		
		#
		# TODO: We are working toward replacing the shock generation with
		#      a calibrated (from PWBMsim data) transition.
		#      As an incremental step, we import the values generated by 
		#      the process above from a csv file.
		
		file      = PathFinder.getMicrosimInputPath('labor_productivity')
		(shocks, transitions) = InputReader.read_transitions(file, yearFirst,(yearLast - yearFirst + 1), T_life)
		file      = PathFinder.getMicrosimInputPath( 'initial_DIST' )
		DISTz     = InputReader.read_initDIST(file, yearFirst, T_life)
		
		# Define population group index mapping
		groups = ['citizen', 'legal', 'illegal']
		ng = len(groups)
		g = dict(zip(groups, list(range(0,ng))))
		
		assert(ng == size(DISTz,3), 'WARNING! Initial distribution file does not contain %u groups.' % ng)
		
		# Define savings and average earnings discretization vectors
		f  = lambda lb, ub, n, curv: lb + (ub-lb)*(list(range(n))/(n-1))^curv
		nk = 12
		kv = f(1e-3, 1/(275*scenario.modelunit_dollar), nk-4, 4)   # savings vector --- the grid is built to range from approx 10 to 1.5 million dollars --- 8.7230e-05 corresponds to the last modelunit_dollar value in steady state
		scale = 1                                                         # scaling parameter to continue building the capital grid 
		for ik in range(nk-4,nk):                                                  # this loop builds the top of capital grid such that:
			scale = 3.5*scale                                          # i.  it re-starts at around 3.5 million dollars
			kv(ik) = scale*1e+6*scenario.modelunit_dollar                   # ii. and its last point is around 150 million dollars 
		ssincmax = 1.185e5                                                  # 118,500 is the maximum annual labor income for Social Security tax purposes
		nb =  5
		bv = f(0, ssincmax*scenario.modelunit_dollar, nb  , 2)  # average earnings vector --- Upper bound of average earnings defined as maximum possible Social Security benefit
		bv = bv.append(15*bv[-1])                                  # max point arbitrarily set to 15x the second largest one
		nb = nb + 1
		
		s['g']        = g
		s['ng']       = ng
		s['nz']       = shape(shocks,3)
		s['transz']   = transitions
		s['DISTz']    = DISTz
		s['zs']       = shocks
		s['nk']       = nk
		s['kv']       = kv
		s['nb']       = nb
		s['bv']       = bv
		
		return s

	## DICRETIZATION GRIDS
	#   Generate grids for assets, average earnings, and labor_productivity
	#   (grids, transition matrices, and initial household distribution)
	def grids_discretization(scenario):
        
        # (Shock process definitions from Storesletten, Telmer, and Yaron, 2004)
        # (Method of discretizing shock process derived from Adda and Cooper, 2003)
        
        # Define function to compute cutoff points for equally weighted slices of a normal distribution
		f = lambda n, sig: n*sig*-np.diff(norm.pdf(norm.ppf(np.linspace(0, 1, num=n+1))))
		
		# Determine permanent and transitory shocks
		nperm  = 2
		zperm  = f(nperm , math.sqrt(0.2105))
		ntrans = 2
		ztrans = f(ntrans, math.sqrt(0.0630))
        
		# Determine persistent shocks
		npers = 2
		
		pep = 0.990                       # Lagged productivity coefficient
		sigep = math.sqrt(0.018)             # Conditional standard deviation of productivity
		sigpers = sigep/(sqrt(1-pep^2))
		
		zpers = f(npers, sigpers)
		
		# Construct Markov transition matrix for persistent shocks by approximating an AR(1) process
		persv = sigpers*norm.ppf(np.linspace(0, 1, n=npers+1))
		transpers = np.zeros(npers,npers)
		for ipers in range(npers):
			integrand = lambda x: math.exp(-x^2/(2*sigpers^2)) * np.diff(norm.cdf((persv(ipers:ipers+1) - pep*x)/sigep));
            for jpers = 1:npers
                transpers(ipers,jpers) = (npers/(sqrt(2*pi*(sigpers^2)))) * quadgk(@(v) arrayfun(integrand, v), persv(jpers), persv(jpers+1));
            end
        end
        
        % Determine initial distribution over persistent shocks
        DISTpers = diff(normcdf(persv/sqrt(0.124)));
        
        % Define deterministic lifecycle productivities
        timing    = ParamGenerator.timing(scenario);
        T_life    = timing.T_life;
        T_workMax = timing.Tmax_work;
        
        % Life-cycle productivity from Conesa et al. 2017 - average for healthy workers
        file      = pathFinder.getMicrosimInputPath( 'ConesaEtAl_WageAgeProfile' );
        series    = InputReader.read_series(file, 'Age', 1 + timing.realage_entry, []);
        zage      = series.Wage;
        
        % Calculate total productivity
        ndem = nperm; nz = ntrans*npers;
        
        zs = max(0, repmat(reshape(zage                       , [1 ,T_life,1   ]), [nz,1     ,ndem]) ...
                  + repmat(reshape(zperm                      , [1 ,1     ,ndem]), [nz,T_life,1   ]) ...
                  + repmat(reshape(kron(ones(1,npers), ztrans) ...
                                 + kron(zpers, ones(1,ntrans)), [nz,1     ,1   ]), [1 ,T_life,ndem]));

        zs_check = zs(:,1:T_workMax,:);
        assert(all(zs_check(:) > 0), 'WARNING! Productivity shock grid contains zero.')
        
        % Construct Markov transition matrix for all shocks / productivities
        transz = kron(transpers, (1/ntrans)*ones(ntrans,ntrans));
        
        % Determine initial distribution over all shocks / productivities
        DISTz0 = kron(DISTpers , (1/ntrans)*ones(1     ,ntrans));

        % Include a fifth super large and rare shock
        nz = 5;
        zs(5,:,:) = zs(4,:,:) * 15;
        transz = [transz(1,1) transz(1,2) transz(1,3) transz(1,4) 0.00;
                  transz(2,1) transz(2,2) 0.02        0.02        (1-(transz(2,1)+transz(2,2))-2*0.02);
                  transz(3,1) transz(3,2) 0.47        0.47        (1-(transz(3,2)+transz(3,2))-2*0.47) ;
                  0.03        0.03        0.47        0.46         0.01                    ;
                  0.15        0.05        0.05        0.25         0.50];
        DISTz0 = [DISTz0 0];
        
        % Determine productivity distributions for ages
        DISTz_g      = zeros(nz,T_life);
        DISTz_g(:,1) = reshape(DISTz0, [nz,1]);
        
        for age = 2:T_life
            DISTz_g(:,age) = transz' * DISTz_g(:,age-1);
        end
        
        % Define population group index mapping
        groups = {'citizen', 'legal', 'illegal'};
        ng = length(groups);
        for ig = 1:ng, g.(groups{ig}) = ig; end
        
        % Replicate age productivity distributions for population groups
        DISTz = repmat(DISTz_g, [1,1,ng]);
        
        % Shift productivity distributions for legal and illegal immigrants towards highest and lowest productivity levels respectively
        %   prem_legal   : productivity premium of avg. (by year) legal
        %          immigrant. Note: This is a ratio.
        %          This value is a policy param on the Scenario.
        %   prem_illegal : productivity premium of avg. (by year) illegal
        %          immigrant. Note: This is a ratio.
        %          This value is calculated by PWBM
        %          at \\SHARED_DRIVE\PWBM_MicroSIM\Outputs\StructuralModelInputs
        prem_legal   = scenario.prem_legal;
        prem_illegal = 0.9; %  TODO: The real value is 0.62043 -- lowest shock is above this;
        for age = 1:T_life
            
            zmean = mean(zs(:,age,:), 3);
            
            if ( zmean .* DISTz(:,age,g.citizen) ~= zmean .* DISTz(:,age,g.legal) * prem_legal )
                zlegal   = sum(zmean .* DISTz(:,age,g.legal  )) * prem_legal  ; 
                plegal   = (zmean(nz) - zlegal  ) / (zmean(nz)*(nz-1) - sum(zmean(1:nz-1)));
                DISTz(:,age,g.legal  ) = [plegal*ones(nz-1,1); 1 - plegal*(nz-1)    ];
            end

            zillegal = sum(zmean .* DISTz(:,age,g.illegal)) * prem_illegal;
            pillegal = (zmean(1)  - zillegal) / (zmean(1) *(nz-1) - sum(zmean(2:nz  )));
            DISTz(:,age,g.illegal) = [1 - pillegal*(nz-1); pillegal*ones(nz-1,1)];
            
        end
        
        % Checks
        assert(all(transz(:) >= 0), 'WARNING! Negative transition probabilities.')
        assert(all(DISTz (:) >= 0), 'WARNING! Negative initial distribution of people DISTz.')
        if scenario.prem_legal==1
            citizen_legal = abs(DISTz(:,:,g.citizen)-DISTz(:,:,g.legal));
            assert(all(citizen_legal(:) < 1e-14), ...
                   'WARNING! Legal immigrants distribution does not match natives distribution although prem_legal = %f.\n', scenario.prem_legal )
        end
        
        % Define savings and average earnings discretization vectors
        f  = @(lb, ub, n, curv) lb + (ub-lb)*((0:n-1)/(n-1))'.^curv;
        nk = 12; kv = f(1e-3, 1/(275*scenario.modelunit_dollar), nk-4, 4);   % savings vector --- the grid is built to range from approx 10 to 1.5 million dollars --- 8.7230e-05 corresponds to the last modelunit_dollar value in steady state
        scale = 1;                                                           % scaling parameter to continue building the capital grid 
        for ik = nk-3:nk                                                     % this loop builds the top of capital grid such that:
            scale = 3.5*scale;                                               % i.  it re-starts at around 3.5 million dollars
            kv(ik) = scale*1e+6*scenario.modelunit_dollar;                   % ii. and its last point is around 150 million dollars 
        end
        ssincmax = 1.185e5;                                                  % 118,500 is the maximum annual labor income for Social Security tax purposes
        nb =  5; bv = f(   0, ssincmax*scenario.modelunit_dollar, nb  , 2);  % average earnings vector --- Upper bound of average earnings defined as maximum possible Social Security benefit
        bv = [bv; 15*bv(end)];                                               % max point arbitrarily set to 15x the second largest one
        nb = nb + 1;
        
        %
        % TODO: We are working toward replacing the shock generation with
        %       a calibrated (from PWBMsim data) transition.
        %       As an incremental step, we move to a larger grid structure
        %       and copy the current transz for all years/types.
        %
        
        % Make the larger sized transz grid and replicate the current transz grid.
        transz      = [transz, zeros(nz); zeros(nz), transz];
        transitions = repmat(transz, [1, 1, T_life]);
        zs          = [zs(:,:,1); zs(:,:,2)];
        DISTz       = [DISTz; DISTz] / 2;
        
        s.ndem     = ndem;
        s.g        = g;
        s.ng       = ng;
        s.nz       = ndem*nz;
        s.transz   = transitions;
        s.DISTz    = DISTz;
        s.zs       = zs;
        s.nk       = nk;
        s.kv       = kv;
        s.nb       = nb;
        s.bv       = bv;
        
    end % grids_discretization
    
    
    %%
    % Output the calculated labor productivity grid as a transitions.csv file
    %   
    function [] = export_labor_productivity( filename1, filename2 )
        
        % TEMP: Use an arbitrary scenario.
        scenario = Scenario(ModelTester.test_params).steady().currentPolicy();
        params   = ParamGenerator.grids_discretization(scenario);
        timing   = ParamGenerator.timing(scenario);
        
        % Export labor productivity grids and transition probabilities
        
        colNames_trans = {'Year', 'Age'};
        for i = 1:params.nz
            colNames_trans(1,end+1) = {sprintf('Value%u', i)};
            for j = 1:params.nz
                colNames_trans(1,end+1) = {sprintf('Transition_%u_%u', i, j)};
            end
        end 

        T = array2table(zeros(0,length(colNames_trans)));
        T.Properties.VariableNames = colNames_trans;
        
        warning( 'off', 'MATLAB:table:RowsAddedExistingVars' );
        
        i = 1;  % rownum
        for age = timing.realage_entry:timing.realage_entry+timing.T_life-1
            a           = age - timing.realage_entry + 1;
            T.Age(i)    = age;
            for z = 1:params.nz
                s = sprintf('Value%u', z);
                T.(s)(i) = params.zs(z, a);
                for zz = 1:params.nz
                    ss = sprintf('Transition_%u_%u', z, zz);
                    T.(ss)(i) = params.transz(z, zz, a);
                end
            end % z
            i = i+1;
        end % age
        
        % TEMP: No time variation, so use steady year and first transition
        T.Year = (timing.TransitionFirstYear - 1)*ones(height(T),1);
        Tout = T;
        T.Year = (timing.TransitionFirstYear)*ones(height(T),1);
        Tout = [Tout; T];
        T.Year = (timing.TransitionFirstYear+1)*ones(height(T),1);
        Tout = [Tout; T];
        
        warning( 'on', 'MATLAB:table:RowsAddedExistingVars' );

        writetable( Tout, filename1, 'WriteRowNames', true);
        
        % Export initial household distribution wrt labor productivity
        colNames_DIST  = {'Year', 'Age'};
        for ig = 1:params.ng
            for iz = 1:params.nz
                colNames_DIST (1,end+1) = {sprintf('Mass_%u_%u', ig , iz)};
            end
        end
        
        D = array2table(zeros(0,length(colNames_DIST)));
        D.Properties.VariableNames = colNames_DIST;
        
        warning( 'off', 'MATLAB:table:RowsAddedExistingVars' );
        
        rownum = 1;
        for age = timing.realage_entry:timing.realage_entry+timing.T_life-1
            model_age     = age - timing.realage_entry + 1;
            D.Age(rownum) = age;
            for ig = 1:params.ng
                for iz = 1:params.nz
                    ss = sprintf('Mass_%u_%u', ig , iz);
                    D.(ss)(rownum) = params.DISTz(iz, model_age, ig);
                end
            end % z
            rownum = rownum+1;
        end % age
        
        % TEMP: No time variation, so use steady year and first transition
        D.Year = (timing.TransitionFirstYear - 1)*ones(height(D),1);
        Dout = D;
        D.Year = (timing.TransitionFirstYear)*ones(height(D),1);
        Dout = [Dout; D];
        D.Year = (timing.TransitionFirstYear+1)*ones(height(D),1);
        Dout = [Dout; D];
        
        warning( 'on', 'MATLAB:table:RowsAddedExistingVars' );

        writetable( Dout, filename2, 'WriteRowNames', true);        

        
    end % export_labor_productivity
    
        
    %% INDIVIDUAL TAXES
    % 
    % Generate tax policy parameters according to predefined plans.
    % 
    function s = taxIndividual( scenario )
        
        timing          = ParamGenerator.timing(scenario);
        T_model         = timing.T_model;
        first_year      = timing.yearFirst;
        last_year       = timing.yearLast;
        
        pathFinder      = PathFinder(scenario);
        
        % Get the capital and tax treatment allocation params.
        %    Rem: These are time-varying, so read results are vectors.
        file     = pathFinder.getTaxCalculatorInputPath( 'CapitalTaxes' );
        tax_vars = InputReader.read_series(file, 'Year', first_year, last_year);       
        % Portion of corporate income taxed at preferred rates
        %   TBD: Fix this when John R. gives new inputs
        s.sharePreferredCorp = tax_vars.sharePreferredCorp;
        s.shareOrdinaryCorp  = tax_vars.shareOrdinaryCorp;
        s.shareOrdinaryPass  = tax_vars.shareOrdinaryPass;       
        % Capital gains tax == zero for now
        s.rateCapGain        = zeros(T_model,1);
        
        % ORDINARY RATES
        % Read Ordinary Rates & Brackets
        file     = pathFinder.getTaxCalculatorInputPath( 'OrdinaryRates' );
        [brackets, rates] = InputReader.read_brackets_rates_indices(file, first_year, T_model);        
        % TBD: This should be done in ModelSolver as for SocialSecurity
        % Calculate cumulative tax burdens along brackets dimension
        burdens         = cumsum(diff(brackets, 1, 2).*rates(:, 1:end-1), 2); 
        burdens         = [zeros(size(brackets, 1), 1), burdens];  % rem: first burden is zero       
        % Convert US dollar amounts into modelunit_dollars
        s.burdens       = burdens  .*scenario.modelunit_dollar;    % Cumulative tax burden
        s.brackets      = brackets .*scenario.modelunit_dollar;    % PIT tax brackets, rem: first one is zero
        s.rates         = rates;                                   % Rate for above each bracket threshold
        
        % Social Security income deductions
        file          = pathFinder.getOASIcalculatorInputPath( 'BenefitTaxes' );
        series        = InputReader.read_series(file, 'Year', first_year , last_year     );
        s.sstaxcredit = 1 - series.BenefitTax;
        
        
        % CONSUMPTION TAX RATES
        % Read Ordinary Rates & Brackets
        file     = pathFinder.getTaxCalculatorInputPath( 'ConsRates' );
        [brackets, rates] = InputReader.read_brackets_rates_indices(file, first_year, T_model);        
        % Calculate cumulative tax burdens along brackets dimension
        burdens         = cumsum(diff(brackets, 1, 2).*rates(:, 1:end-1), 2); 
        burdens         = [zeros(size(brackets, 1), 1), burdens];  % rem: first burden is zero       
        % Convert US dollar amounts into modelunit_dollars
        s.consburdens       = burdens  .*scenario.modelunit_dollar;    % Cumulative tax burden
        s.consbrackets      = brackets .*scenario.modelunit_dollar;    % Consumption tax brackets, rem: first one is zero
        s.consrates         = rates;                                   % Rate for above each bracket threshold
        
        
        % PREFERRED RATES
        % Read Preferred Rates & Brackets
        file     = pathFinder.getTaxCalculatorInputPath('PreferredRates' );
        [brackets, rates] = InputReader.read_brackets_rates_indices(file, first_year, T_model);       
        % TBD: This should be done in ModelSolver as for SocialSecurity
        % Calculate cumulative tax burdens along brackets dimension
        burdens         = cumsum(diff(brackets, 1, 2).*rates(:, 1:end-1), 2); 
        burdens         = [zeros(size(brackets, 1), 1), burdens];  % rem: first burden is zero
        % Convert US dollar amounts into modelunit_dollars
        s.prefburdens   = burdens  .*scenario.modelunit_dollar;    % Cumulative tax burden
        s.prefbrackets  = brackets .*scenario.modelunit_dollar;    % Preferred Rate tax brackets, rem: first one is zero
        s.prefrates     = rates;                                   % Rate for above each bracket threshold
        
        % Warn if parameters are outside expectations
        if( any(s.sharePreferredCorp < 0) || any(s.sharePreferredCorp > 1) )
            fprintf( 'WARNING! ParamGenerator.taxIndividual.sharePreferredCorp outside expecations.\n' );
        end
        if( any(s.shareOrdinaryCorp < 0) || any(s.shareOrdinaryCorp > 1) )
            fprintf( 'WARNING! ParamGenerator.taxIndividual.shareOrdinaryCorp outside expecations.\n' );
        end
        if( any(s.shareOrdinaryPass < 0) || any(s.shareOrdinaryPass > 1) )
            fprintf( 'WARNING! ParamGenerator.taxIndividual.shareOrdinaryPass outside expecations.\n' );
        end
        
        %% TBD: Enlarge the space of error checks
        
    end  % taxIndividual()


    %% BUSINESS TAXES
    % 
    % Generate tax policy parameters according to predefined plans.
    % 
    function s = taxBusiness( scenario )
        
        timing          = ParamGenerator.timing(scenario);
        T_model         = timing.T_model;
        first_year      = timing.yearFirst;
        last_year       = timing.yearLast;
        
        pathFinder = PathFinder(scenario);
        
        % Get the capital and tax treatment allocation params. 
        %    Rem: These are time-varying, so read results are vectors.
        file     = pathFinder.getTaxCalculatorInputPath( 'CapitalTaxes' );
        tax_vars = InputReader.read_series(file, 'Year', first_year, last_year);
        
        % Pass along all capital tax parameters 
        for f = fieldnames(tax_vars)'
            s.(f{1}) = tax_vars.(f{1});
        end
        
        % Income shares sum to 1
        s.shareIncomePass = 1 - s.shareIncomeCorp;
        % Tax rate on total foreigner's business income
        s.rateForeignBusinessIncome = s.shareIncomeCorp .* s.rateForeignerCorpIncome ...
                                    + s.shareIncomePass .* s.rateForeignerPassIncome;
        
        % Get the household ordinary tax treatment allocation params to use as pass-through rate. 
        %    Rem: These are time-varying, so read results are vectors.
        file     = pathFinder.getTaxCalculatorInputPath( 'OrdinaryRates' );
        [~, pass_rates] = InputReader.read_brackets_rates_indices(file, first_year, T_model);        
        s.ratePass      = pass_rates(:,end);
        
               
        % Warn if parameters are outside expectations
        if( any(s.rateExpensingCorp < 0) || any(s.rateExpensingCorp > 1) )
            fprintf( 'WARNING! ParamGenerator.taxBusiness.rateExpensingCorp outside expectations.\n' );
        end
        if( any(s.rateExpensingPass < 0) || any(s.rateExpensingPass > 1) )
            fprintf( 'WARNING! ParamGenerator.taxBusiness.rateExpensingPass outside expectations.\n' );
        end
        if( any(s.rateCorpStatutory < 0) || any( s.rateCorpStatutory > 1 ) )
            fprintf( 'WARNING! ParamGenerator.taxBusiness.rateCorpStatutory outside expectations.\n' );
        end
        %% TBD: Enlarge the space of error checks
        
    end  % taxBusiness()

    
    
    
    %% DEMOGRAPHICS
    %     Includes:
    %          survival probabilities
    %        , immigrant age distribution
    %        , birth rate
    %        , legal immigration rate
    %        , illegal immigration rate
    function s = demographics( scenario ) 
        
        pathFinder = PathFinder(scenario);
        
        timing    = ParamGenerator.timing( scenario );
        grids     = ParamGenerator.grids(  scenario );
        
        % TBD: import time-varying demographics
        file         = pathFinder.getDemographicsInputPath( 'rates' );
        demographics = InputReader.read_demographics(file, 2018, timing.T_model, timing.realage_entry, timing.T_life, grids.g);
        % Note: starting year is 2018 in read_demographics because input file still lacks 2017. Replace by timing.yearFirst.
        % Each field in demographics is a (T_model x T_life) matrix
        
        % Population per year (total and by age)
        population     = sum(demographics.citizen.Population + demographics.legal.Population + demographics.illegal.Population, 2);
        population_age = demographics.citizen.Population + demographics.legal.Population + demographics.illegal.Population;
        
        % Time-varying survival probabilities by age
        deaths = demographics.citizen.Died + demographics.legal.Died + demographics.illegal.Died;
        surv   = 1 - (deaths ./ population_age);
                
        % Time-varying birth rates
        birth_rate = demographics.citizen.Born(:,1) ./ population;
        
        % Time-varying entry rates by age
        % Note: Immigrants that arrived before age 21 are accounted for as new borns
        legal_rate_age   = [demographics.legal.Born(:,1)                                                       ...
                          + demographics.legal.Immigrated(:,1)     - demographics.legal.Emigrated(:,1)         ...
                            demographics.legal.Immigrated(:,2:end) - demographics.legal.Emigrated(:,2:end)     ...
                            ] ./ population;
        illegal_rate_age = [demographics.illegal.Born(:,1)                                                     ...
                          + demographics.illegal.Immigrated(:,1) - demographics.illegal.Emigrated(:,1)         ...
                            demographics.illegal.Immigrated(:,2:end) - demographics.illegal.Emigrated(:,2:end) ...
                            ] ./ population;
        % TBD: Allow for negative NET entry rates
        legal_rate_age  ((  legal_rate_age < 0)) = 0;
        illegal_rate_age((illegal_rate_age < 0)) = 0;
        
        % TBD: use new inputs and erase old inputs
%         s.surv             = surv;                    % Survival probabilities per year and age
%         s.birth_rate       = birth_rate;              % Birth rate per year
%         s.legal_rate_age   = legal_rate_age;          % Legal immigration rate per year and age
%         s.illegal_rate_age = illegal_rate_age;        % Illegal immigration rate per year and age

        % End TBD
                                                
        file      = pathFinder.getMicrosimInputPath( 'SurvivalProbability' );
        series    = InputReader.read_series( file, 'Age', 1 + timing.realage_entry, [] );
        survival  = series.SurvivalProbability';
        if( length(survival) ~= timing.T_life )
            throw(MException('timing:survival','Survival probabilities must exist for every age.'));
        end
        
        file      = pathFinder.getMicrosimInputPath( 'ImmigrantAgeDistribution' );
        series    = InputReader.read_series( file, 'Age', 1 + timing.realage_entry, [] );
        imm_age   = series.ImmigrantAgeDistribution;
        if( length(imm_age) ~= timing.T_life )
            throw(MException('timing:imm_age','Immigrant age distributions must exist for every age.'));
        end
        
        s.surv             = repmat(reshape(survival, [1, timing.T_life]), [timing.T_model, 1]);
        s.birth_rate       = 0.018923919 * ones(timing.T_model,1);                      % Birth rate by year
        s.legal_rate_age   = 0.002371966 * imm_age' .* ones(timing.T_model,1);          % Net entry rate of legal migrants by age & year
        s.illegal_rate_age = 0.000836294 * imm_age' .* ones(timing.T_model,1);          % Net entry rate of illegal migrants by age & year

    end % demographics
    
       %% OUT OF MODEL ADJUSTMENTS
    %     Includes:
    %         TFP
    function s = outofmodel( scenario ) 

        timing      = ParamGenerator.timing( scenario );
        first_year  = timing.yearFirst;
        last_year   = timing.yearLast;
        
        pathFinder  = PathFinder(scenario);

        % Import the out-of-model parameters and variables
        file        = pathFinder.getOutOfModelInputPath( 'outofmodel' );
        series      = InputReader.read_series(file, 'Year', first_year, last_year);
        
        s.TFP           = series.TFP;
        s.infraSpending = series.infraSpending;
        s.lumpSumTaxes  = series.lumpSumTax;
           
    end % outofmodel
    
    %% PRODUCTION
    %     Includes:
    %        , depreciation
    %        , capital share
    function s = production( scenario )
        
        % TBD: These are hard coded for now, until we resolve sourcing
        s.alpha         = 0.34;                 % Capital share of output
        s.risk_premium  = 0;
        s.depreciation  = 0.056;                % Actual depreciation rate
        if( scenario.IsLowReturn )
            s.risk_premium  = 0.08 - s.depreciation; % "Depreciation rate" to generate r=risk-free rate         ;
        end
        
        s.capitalAdjustmentCost = scenario.CapitalAdjustmentCost;
        s.allowBusinessDebt     = scenario.AllowBusinessDebt;
        s.leverageSensitivity   = scenario.LeverageSensitivity;
        
        % Find initial year business debt / capital leverage ratios
        %   TEMP: This should come from interface
        %         For now, this is from Barro-Furman 2018
        s.leverageCorp0         = 0.32;
        s.leveragePass0         = 0.32;

    end % production
        
    
    %% SOCIAL SECURITY
    %
    function s = social_security( scenario )
        
        timing                  = ParamGenerator.timing(scenario);
        T_model                 = timing.T_model;
        T_life                  = timing.T_life;
        first_year              = timing.yearFirst;
        last_year               = timing.yearLast;
        nstartyears             = length(timing.startyears);
        realage_entry           = timing.realage_entry;
        
        pathFinder = PathFinder(scenario);
        
        % Get T_works (retirement ages)
        nrafile = pathFinder.getOASIcalculatorInputPath( 'retirementAges' );
        
        if (scenario.isSteady() )
            survivalprob = ParamGenerator.demographics(scenario).surv;
            series       = InputReader.read_series( nrafile, 'birthYear', first_year - (T_life + realage_entry), [] );
            T_works      = round(series.NRA);
            mass         = ones(T_life,1); for i = 2:T_life; mass(i) = mass(i-1)*survivalprob(i-1); end
            T_works      = round(sum((mass.*T_works(1:T_life))/sum(mass))) - realage_entry;
        else
            series       = InputReader.read_series( nrafile, 'birthYear', first_year - (T_life + realage_entry), last_year );
            T_works      = round(series.NRA);
            T_works      = T_works(1:nstartyears) - realage_entry;
        end
        s.T_works           = T_works;
        retire_years        = zeros(nstartyears, 1);
        for i = 1:nstartyears
            retire_years(i)  =  (i - T_life) + T_works(i);
        end
        s.retire_years      = retire_years;
        
        %  TAXATION
        
        % Read tax brackets and rates on payroll 
        %   Pad if file years do not go to T_model, truncate if too long
        %   Calculate cumulative liability to speed up calculation 
        %   Convert from US dollars to modelunit dollars
        file = pathFinder.getOASIcalculatorInputPath( 'TaxParameters' );
        [brackets, rates, indices] = InputReader.read_brackets_rates_indices(file, first_year, T_model);
        
        if( size(indices,2) ~= size(brackets,2) )
            throw(MException('social_security:TAXBRACKETS','SSTaxBrackets and BracketsIndexes must have same number of brackets.'));
        end    
    
        s.taxbrackets   = brackets .*scenario.modelunit_dollar;     % Payroll tax brackets, rem: first one is zero
        s.taxrates      = rates                               ;     % Rate for above each bracket threshold
        s.taxindices    = indices                             ;     % Type of index to use for the bracket change
        
        % BENEFITS
        
        % Get range of income which is credited toward benefit calculation
        file       = pathFinder.getOASIcalculatorInputPath( 'BenefitParameters' );
        [brackets] = InputReader.read_brackets_rates_indices(file, first_year, T_model);
        
        s.ssincmins = (brackets(:, 1) * scenario.modelunit_dollar)';
        s.ssincmaxs = (brackets(:, 2) * scenario.modelunit_dollar)';
        
        % Fetch initial benefits for each cohort 
        %   REM: Benefits are per month in US dollars 
        %        in year = first_transition_year - 1
        first_birthyear = first_year - (T_life + realage_entry);
        last_birthyear  = first_birthyear + nstartyears - 1;
        
        file    = pathFinder.getOASIcalculatorInputPath( 'PIAParameters' );
        cohorts = InputReader.read_cohort_brackets_rates_indices(file, first_year, T_model, first_birthyear, last_birthyear);
        
        % Convert birthyears into model startyears
        % Convert monthly brackets into model units and yearly
        for bYear = first_birthyear:last_birthyear
           birthYearField = sprintf('b%u', bYear); 
           i              = bYear - first_birthyear + 1;  % cohort number
           brackets       = cohorts.(birthYearField).brackets * 12 * scenario.modelunit_dollar;
           rates          = cohorts.(birthYearField).rates;
           s.benefitParamsByCohort{i} = struct('brackets', brackets, 'rates', rates);
        end
        
    end % social_security
    
    
    %% BUDGET AND INTEREST RATES
    %
    function s = budget( scenario )
        
        timing                  = ParamGenerator.timing( scenario );
        T_model                 = timing.T_model;
        T_life                  = timing.T_life;
        first_year              = timing.yearFirst;
        last_year               = timing.yearLast;
        
        isSteadyEconomy         = scenario.isSteady();
        
        pathFinder = PathFinder(scenario);
                
        projections_file   = pathFinder.getProjectionsInputPath( 'Projections' );
        projections_series = InputReader.read_series(projections_file, 'Year', first_year                      , last_year     );

        deepHistory_file   = pathFinder.getProjectionsInputPath( 'DeepHistory' );
        history_series     = InputReader.read_series(deepHistory_file, 'Year', first_year - T_life + 1  , last_year);
        
        taxcalculator_file      = pathFinder.getTaxCalculatorInputPath( 'Aggregates' );
        taxcalculator_series    = InputReader.read_series(taxcalculator_file, 'Year', first_year               , last_year );
        
        oasicalculator_file     = pathFinder.getOASIcalculatorInputPath( 'aggregates' );
        oasicalculator_series   = InputReader.read_series(oasicalculator_file, 'Year', first_year               , last_year );
        
        f_revenues = @(t, o) ...
            ...
            + t.RevenuesIndividualIncomeTax         ...
            + t.RevenuesPayrollTaxExSocialSecurity  ...
            + t.RevenuesCorporateIncomeTax          ...
            + t.RevenuesEstateAndGiftTaxes          ...
            + t.RevenuesExciseTaxes                 ...
            + t.RevenuesCustomsDuties               ...
            + t.RevenuesMiscellaneousReceipts       ...
            + t.RevenuesPayrollTaxSocialSecurity    ...
            ...
        ;
        revenues      = f_revenues(taxcalculator_series     , oasicalculator_series     );
        
        f_noninterestspending = @(p, t, o) ...
            ...
            + p.OutlaysDiscretionary        ...
            + p.OutlaysMedicare             ...
            + p.OutlaysMedicaid             ...
            + p.OutlaysFederalRetirement    ...
            + p.OutlaysVeteransPrograms     ...
            + p.OutlaysOtherPrograms        ...
            + p.OutlaysOffsettingReceipts   ...
            ...
            + t.OutlaysIncomeSecurity       ...
            ...
            + o.OutlaysSocialSecurity       ...
            ...
        ;
        noninterestspending      = f_noninterestspending(projections_series     , taxcalculator_series     , oasicalculator_series     );
        
        % Only calculate debttoout for steady
        if( isSteadyEconomy )
            projections_past_series     = InputReader.read_series(projections_file   , 'Year', first_year, first_year);
            taxcalculator_past_series   = InputReader.read_series(taxcalculator_file , 'Year', first_year, first_year);
            oasicalculator_past_series  = InputReader.read_series(oasicalculator_file, 'Year', first_year, first_year);

            past_noninterestspending    = f_noninterestspending(projections_past_series, taxcalculator_past_series, oasicalculator_past_series);
            past_revenues               = f_revenues(taxcalculator_past_series, oasicalculator_past_series);

            % Calculate debt to get DEBT/GDP for first_year
            deficit_nis     = past_revenues - past_noninterestspending;
            debt            = zeros(size(deficit_nis));
            debt(1)         = projections_series.DebtHeldByThePublic(1);
            for i = 2:size(deficit_nis)
                debt(i) = debt(i-1)*(1+projections_past_series.AverageInterestRateOnDebt(i)) - deficit_nis(i);
            end
            s.debttoout     = debt(end) / projections_series.GDP_FY(1);
        end
        
        
        % Rates
        %    For interest rate in steady-state, we use avg. rate across all data
        %    NOTE: EffectiveInterestRateOnDebt is in NOMINAL terms and we
        %    deflate by GDPDeflator. We therefore need N+1 GDPDeflators to
        %    match N interest rates.
        if( isSteadyEconomy )
            GDPdeflator_series = InputReader.read_series(projections_file, 'Year', first_year, []           );
        else
            GDPdeflator_series = InputReader.read_series(projections_file, 'Year', first_year, last_year + 1);
        end
        
        % We need to load in history for the deflator series to get a value
        % for the real interest rate on bonds in the steady state.
        
        GDPdeflator_series_temp = InputReader.read_series(projections_file, 'Year', first_year-1, first_year);
        steadyStatePriceGrowth = GDPdeflator_series_temp.GDPDeflator(2)/GDPdeflator_series_temp.GDPDeflator(1);
        clear GDPdeflator_series_temp;
        
        % Loading in the treasury rates from the projections interface.
        
        treas1yr        = projections_series.TreasuryYield1yr/100;
        treas2yr        = projections_series.TreasuryYield2yr/100;
        treas3yr        = projections_series.TreasuryYield3yr/100;
        treas5yr        = projections_series.TreasuryYield5yr/100;
        treas7yr        = projections_series.TreasuryYield7yr/100;
        treas10yr       = projections_series.TreasuryYield10yr/100;
        treas30yr       = projections_series.TreasuryYield30yr/100;
        
        gdpPriceIndex0  = GDPdeflator_series.GDPDeflator(1);  
        gdpPriceIndex   = GDPdeflator_series.GDPDeflator(2:end);
        num_rates       = size(gdpPriceIndex);
        interest_rate   = GDPdeflator_series.AverageInterestRateOnDebt(1:num_rates);
        
        deflator_rate           = zeros(num_rates);
        deflator_rate(1)        = gdpPriceIndex(1) / gdpPriceIndex0;
        for i = 2:num_rates
            deflator_rate(i)    = gdpPriceIndex(i)/gdpPriceIndex(i-1);
        end
        rates_adjusted          = ((1 + interest_rate)./deflator_rate) - 1.0;    
        
        if( isSteadyEconomy )
            s.debtrates = nanmean( rates_adjusted );
        else
            s.debtrates = rates_adjusted';
        end
        
        if( isSteadyEconomy )
            s.treas1yr = nanmean( treas1yr);
            s.treas2yr = nanmean( treas2yr);
            s.treas3yr = nanmean( treas3yr);
            s.treas5yr = nanmean( treas5yr);
            s.treas7yr = nanmean( treas7yr);
            s.treas10yr = nanmean( treas10yr);
            s.treas30yr = nanmean( treas30yr); 
        else
            s.treas1yr = treas1yr';
            s.treas2yr = treas2yr';
            s.treas3yr = treas3yr';
            s.treas5yr = treas5yr';
            s.treas7yr = treas7yr';
            s.treas10yr = treas10yr';
            s.treas30yr = treas30yr';
        end
       
        % Personal consumption expenditure price index
        s.steadyStatePriceGrowth = steadyStatePriceGrowth;
        s.deflator     = (projections_series.PCEDeflator / projections_series.PCEDeflator(1))'; % normalize to 1 for first_year
        PCEdeflator    = [ history_series.PCEDeflator(1:end-T_model); projections_series.PCEDeflator ];
        s.longDeflator = (PCEdeflator / PCEdeflator(T_life))';

        % TAX REVENUE AND EXPENDITURE TARGETS           
        s.tax_revenue_by_GDP = (revenues            ./ projections_series.GDP_FY)';
        s.outlays_by_GDP     = (noninterestspending ./ projections_series.GDP_FY)';
        
        
        % WARNINGS if parameters are outside expectations
        if( scenario.isSteady() )
            if( (s.debttoout < 0.6) || (s.debttoout > 1.0) )
                fprintf( 'WARNING! debttoout=%f outside expectations.\n', debttoout );
            end
        end
        for t = 2:T_model
            if( abs((s.deflator(t)/s.deflator(t-1))-1 > 0.05 ) )
                fprintf( 'WARNING! cpe deflator outside expectations. \n' );
            end
        end
        
        % Check if all entries are numerical
        fields = fieldnames(s);
        for i = 1:size(fields,1)
            assert( ~any( isnan( s.(fields{i}) ) ), ...
                   'Series %s contains NaN elements.', fields{i});
        end
                
    end % budget
    
    
    %% BEQUEST MOTIVE
    %
    function s = bequest_motive(scenario)
        % phi1 reflects parent's concern about leaving bequests to her children (-9.5 in De Nardi's calibration)
        % phi2 measures the extent to which bequests are a luxury good
        % phi3 is the relative risk aversion coefficient
        
        s.phi1 = scenario.bequest_phi_1;   
        s.phi2 = 11.6;                     
        s.phi3 = 1 - (1 - scenario.sigma)*scenario.gamma;    

    end % bequest_motive
        
    
    %%
    %  OPENNESS OF ECONOMY AND INTERNATIONAL STUFF
    function s = international( scenario )
        
        timing          = ParamGenerator.timing(scenario);
        first_year      = timing.yearFirst;
        last_year       = timing.yearLast;
        
        % debtTakeUp is the percentage of new debt that is
        % acquired by foreigners. New Debt = D' - D
        % capitalTakeUp is the percentage of 'optimal' capital that
        % is acquired by foreigners. Optimal capital = K_f (open)
        % which is the amount of capital which would be taken up by
        % foreigners in the 'open' economy.
        
        pathFinder      = PathFinder(scenario);
        opennessfile    = pathFinder.getOpennessInputPath( 'Openness' );
        series          = InputReader.read_series(opennessfile, 'Year', first_year, last_year);
        s.capitalTakeUp = series.CapitalTakeUp';
        s.debtTakeUp    = series.DebtTakeUp';
        
    end % international

    
    %% ELASTICITY INVERSION
    % 
    % Invert target elasticities using calibration points
    %   Reusable inverter constructed in the process
    % 
    function [inverse] = invert(targets)
        
        % TODO -- revisit the Calibration process
        %   for now just pick one of two hardcoded targets
        % BEGIN TEMP
        inverse = struct(           ...
           'beta'               , 0.9945000000000         ...
    ,      'gamma'              , 0.7210000000000         ...
    ,      'sigma'              , 1.600000000000000       ...
    ,      'bequest_phi_1'      , 0                       ...
    ,      'modelunit_dollar'   , 3.60000000e-05          ...
                );

        if( isfield( targets, 'IsLowReturn' ) )
            if ( targets.IsLowReturn ) 
                fprintf( 'WARNING: Low return economy was not re-calibrated. \n' );
                inverse = struct(                         ...
           'beta'               , 0.99910000000           ...
    ,      'gamma'              , 0.71300000000000        ...
    ,      'sigma'              , 1.600000000000000       ...
    ,      'bequest_phi_1'      , 0                       ...
    ,      'modelunit_dollar'   , 3.795000000e-05         ...
               );
            end
        end
        
        return;
        %  END TEMP
        
        % Load calibration points from calibration input directory
        s = load(fullfile(PathFinder.getCalibrationInputDir(), 'calibration.mat'));
        paramv  = s.paramv ;
        targetv = s.targetv;
        solved  = s.solved ;
        
        % Determine list of calibration parameters
        paramlist = fieldnames(paramv)';
        
        % Construct inverse interpolants that map individual target values to calibration parameters
        %   Target values include capital-to-output ratio in addition to elasticities
        for p = paramlist
            interp.(p{1}) = scatteredInterpolant(...
                targetv.captoout(solved)', ...
                targetv.labelas (solved)', ...
                targetv.savelas (solved)', ...
                paramv.(p{1})(solved)', 'nearest');
        end
        
        % Construct elasticity inverter by consolidating inverse interpolants
        %   Capital-to-output ratio target fixed at 3
        function [inverse] = f_(targets)
            captoout = 3;
            for p_ = paramlist
                inverse.(p_{1}) = interp.(p_{1})(captoout, targets.labelas, targets.savelas);
            end
        end
        f = @f_;
        
        % Invert target elasticities if provided
        if exist('targets', 'var'), inverse = f(targets); else, inverse = struct(); end
        
    end
    
    
end % methods

end % class ParamGenerator


%%  END FILE
